<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <title>Building An Http Server - Jaiden Cole Flannery</title>
        <link rel="stylesheet" href="../styles.css">
        <link rel="icon" href="../img/favicon.ico" type="image/x-icon">
        <link rel="shortcut icon" href="../img/favicon.ico" type="image/x-icon">
    </head>

    <body>
        <nav class="navbar">
            <div class="navbar-container">
                        <span><a href="../blog.html" class="no-anim">üññ</a></span>
                </div>
            </div>
        </nav>

        <main>

            <div class="section-text-blog">
                <h2 class="section-title">Building an HTTP Webserver</h2>
                <span>
                    <pre>
I am a strong believer that to truly understand something, you have to build it yourself; and after working with .NET‚Äôs web api framework for a while, I started to wonder, what is really going on here?
So, out of pure curiosity (and perhaps my own vanity) I decided to build my own web server from scratch - starting with simple intranet http communication.

To start, let‚Äôs touch on how a basic web server functions:
It all starts via TCP (Transmission Control Protocol) which delivers an ordered, error checked stream of bytes over an IP network.
Built on top of TCP is HTTP (HyperText Transfer Protocol) which is a client-server model for user to server interaction (mostly retrieval and interaction with data
the server provides, but can also be used for machine to machine or peer to peer communication). HTTP provides an access layer similar to the RESTful (Representational State Transfer) API, with GET, POST, PUT, PATCH, and DELETE at our disposal.
An easier way to think of it is that HTTP is a ruleset for the client and recipient to both follow, by following the rules you guarantee a universal communication standard and do not have to worry about what structure the server, or client, expects in return.

So‚Ä¶ How do we build a server for HTTP communication?
Well, we have to begin by setting a socket with our OS and telling it to listen for any responses to a specific ip/port (prefix) and to give us the data received.
From there, we‚Äôd parse the bytes and run handlers to do something with that data, such as respond with a HTML file, or just return informational data like ‚ÄúThe server is running!‚Äù.
Luckily for us, .NET comes with an HTTPListener class we can use to abstract past the HTTP structure level and focus on server logic (although, in the near future we will be reimplementing this class ourselves so that we can handle different connection types - such as UDP - and create a more efficient system).

(Quick note, all of the following functions are currently under a single namespace for modularity unless stated otherwise - it allows us to abstract what should be returned in our server logic, and later swap out HttpListener for a socket based connection handler)

To begin, we need to understand what IP addresses exist on our current network so we can ‚Äúlisten‚Äù to them, to do this we can use .NET‚Äôs Dns class to resolve our intranet IPs:

private static List&lt;IPAddress&gt; GetLocalAddresses()
{
    IPHostEntry host;
    host = Dns.GetHostEntry(Dns.GetHostName());
    List&lt;IPAddress&gt; localAddresses = host.AddressList.Where(ip => ip.AddressFamily ==
AddressFamily.InterNetwork).ToList();
    Console.WriteLine(" > Local Addresses:");
    foreach (var ip in localAddresses)
    {
        Console.WriteLine($" [ {ip} ]");
    }
    Console.WriteLine($"\n");
    return localAddresses;
}

Here, we are instantiating an object to hold our values, ‚Äúhost‚Äù, and then call the static function off the Dns class GetHostEntry, which returns an IPHostEntry object containing our local intranet information.<br>
We filter this list for IPv4 addresses specifically, since typically most standard local networks will use IPv4, and we know for a fact all communication will be ported out of IPv4 addresses.<br>
We log this to the console and return the list of local addresses we just found.<br>

I also went ahead and threw in a domain resolver function so we can grab external IPs, but we will not be using it for now - noting it here in the meantime incase of curiosity:

private static async Task&lt;List&lt;IPAddress&gt;&gt;> ResolveAddressAsync()
{
    var ext = await Dns.GetHostAddressesAsync("google.com");
    var externalAddresses = ext.Where(ip => ip.AddressFamily == AddressFamily.InterNetwork).ToList();
    Console.WriteLine("\nRequested Addresses: ");
    foreach (var ip in externalAddresses)
    {
        Console.WriteLine($" : {ip}");
    }
    return externalAddresses;
}

Now that we know what our intranet looks like, we can actually start listening! 

HttpListener requires we instantiate it as an object - so we can declare it and then provide the URIs we‚Äôd like for it to listen to (referred to as prefixes), then we simply call .Start() on our object and our server tells the OS it‚Äôs ready to receive.
But! We need to make sure we‚Äôre listening endlessly and that the server is not going to tell the OS it‚Äôs ready and then shut down. 
I begin this cycle within a function that checks validity, instantiates the HttpListener object, and then adds a quick manual IP for our current machine + the port I have chosen to use (warning, some ports are taken by default, I am on a Mac so to verify I ran ‚Äúsudo lsof -i -n -P | grep TC‚Äù to verify port availability).
Then we call GetLocalAddresses() and iterate on our list to append them onto our listener.Prefixes list.
Finally, we can call listener.Start(), and Task.Run on RunServer(listener).

This is where our infinite runtime come from - RunServer never returns, it just cycles indefinitely, so our InitializeListener() task is left in limbo waiting for a response (reminds me of my dating life)

public async static Task&lt;HttpListener&gt; InitializeListener()
{
    Console.WriteLine(" > Initializing Listener\n\n");

    if (!HttpListener.IsSupported)
    {
        Console.WriteLine(" ! Cannot initialize listener on current OS.\n");
        return null;
    }

    HttpListener listener = new HttpListener();

    listener.Prefixes.Add("http://localhost:8080/");
    var localAddresses = GetLocalAddresses();
    foreach (var ip in localAddresses)
    {
        listener.Prefixes.Add("http://" + ip.ToString() + ":8080/");
    }

    listener.Start();

    await Task.Run(() => RunServer(listener));
    return null;
}

RunServer() then serves one purpose, endlessly running the function StartConnectionListener so we‚Äôre constantly checking for any hits on our prefixes and grabbing the context.
This may change for better implementation in the future, but for now I decided this was fine.

private async static Task&lt;Boolean&gt; RunServer(HttpListener listener)
{
    while (true)
    {
        await StartConnectionListener(listener);
    }
}

private async static Task StartConnectionListener(HttpListener listener)
{
    try
    {
        HttpListenerContext _context = await listener.GetContextAsync();
        try
        {
            Status.Response(_context, _pool);
        }
        catch (Exception err)
        {
            Console.WriteLine($" ! Error: {err}\n");
        }
        finally
        {
            _pool.Release();
        }
    }
    catch (HttpListenerException err)
    {
        Console.WriteLine($" ! Error: {err}\n");
    }
}

Here, we set _context to await listener.GetContextAsync(), which will spin until the listener returns data (our port is hit), so we can then call our response function. 
You may notice we‚Äôre doing a _pool.Release() at the bottom, this is where we begin introducing multithreading to our server so that we can handle multiple requests at once.
At the Listener class level, we declare:

private const int maxConcurrentConnections = 4;
private static SemaphoreSlim _pool = new SemaphoreSlim(maxConcurrentConnections, maxConcurrentConnections);

We are temporarily allocating 4 maximum threads, and using a semaphore for tracking how many threads are in use.
For context, a semaphore is a method in concurrent programming for tracking how many threads are in use, it basically implements a stack where each thread can grab the top of our stack, and if a thread checks and there are no tokens to grab, it waits until one of the threads returns the token (_pool.Release()).
Instead of the .NET Semaphore class, we use SemaphoreSlim due to it being significantly cheaper (does not rely on the OS until it is out of tokens) and for the fact is allows us to take advantage of .WaitAsync(), which we can temporarily return a token until an asynchronous job is ready to continue processing.
Obviously we currently have 0 use for this, but this is an easy swap we can do for our future selves.

Status exists in a separate namespace, I will be using this purely for checking status and interacting with our components to check if data is being mutated properly.
For now, it‚Äôs touch and go, we form a string that holds HTML structured content, push it into a byte array, tell and then push that into our response alongside information about what our data looks like. Response.OutputStream.Write() handles all the actual pushing for us, and we just have to close it out whenever its finished so we dont hold that connection.

public async static void Response(HttpListenerContext _context, SemaphoreSlim _pool)
{
    await _pool.WaitAsync();
    string response = "&lt;html&gt;&lt;body&gt;Status: Running!&lt;/html&gt;&lt;/body&gt;";
    byte[] encoded = Encoding.UTF8.GetBytes(response);
    _context.Response.ContentLength64 = encoded.Length;
    _context.Response.OutputStream.Write(encoded, 0, response.Length);
    _context.Response.OutputStream.Close();
    Console.WriteLine($" > Request [{DateTime.Now:T}] {_context.Request.HttpMethod} {_context.Request.Url}");
}

As you saw in StartConnectionListener(), once Response() returns, successfully or not, we free that token.
StartConnectionListener() finishes, and then instantly gets spun back up by RunServer.

Now we can build our .csproj file (I wanted to build this purely from scratch, so my monkey brain wrote the .csproj by hand. I recommend everyone do this, it is astoundingly simple and clarifies a few points on how much control you have over your projects.)
And run! You should see something like this:


[ Starting Local HTTP Webserver ] 


> Initializing Listener


> Local Addresses:
[ 127.0.0.1 ]

127.0.0.1 is your localhost, which you are not listening on.
Visit http://127.0.0.1:8080 in your browser and see your HTML loaded! Technically, we could just directly return ‚ÄúStatus: Running!‚Äù and the browser would understand, but it is up to your personal discretion and use-case.
                    </pre>
                    </span>
                <br>
            </div>
        </main>

        <script src="script.js"></script>

    </body>

</html>
